#    MIT License
#
#    Copyright (c) 2018-2020 Fredrik Mellbin
#
#    Permission is hereby granted, free of charge, to any person obtaining a copy
#    of this software and associated documentation files (the "Software"), to deal
#    in the Software without restriction, including without limitation the rights
#    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#    copies of the Software, and to permit persons to whom the Software is
#    furnished to do so, subject to the following conditions:
#
#    The above copyright notice and this permission notice shall be included in all
#    copies or substantial portions of the Software.
#
#    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#    SOFTWARE.

import argparse
import sys
from pathlib import Path
from typing import NoReturn, Sequence, Union

from .actions import (
    detect_installed_packages, install_package, list_available_packages, list_installed_packages, rebuild_distinfo,
    set_variables, uninstall_package, update_genstubs, update_package_definition, upgrade_files, upgrade_package
)
from .utils import InstalledPackages, InstallPackageResult, VSPackages, get_installation_info

__all__ = [
    'main'
]


class NoExitArgumentParser(argparse.ArgumentParser):
    exit_on_error: bool

    def error(self, message: str) -> NoReturn:
        if self.exit_on_error:
            super().error(message)
        raise ValueError(message)


def main(argv: Union[Sequence[str], None] = None, exit_on_error: bool = False) -> None:
    parser = NoExitArgumentParser(description='A simple VapourSynth package manager')
    parser.exit_on_error = exit_on_error

    parser.add_argument(
        'operation', choices=[
            'install', 'update', 'upgrade', 'upgrade-all', 'uninstall',
            'installed', 'available', 'paths', 'genstubs', 'gendistinfo'
        ]
    )
    parser.add_argument('package', nargs='*', help='identifier, namespace or module to install, upgrade or uninstall')
    parser.add_argument(
        '-f', action='store_true', dest='force', help='force upgrade for packages where the current version is unknown'
    )
    parser.add_argument('-p', action='store_true', dest='portable', help='use paths suitable for portable installs')
    parser.add_argument('-d', action='store_true', dest='skip_deps', help='skip installing dependencies')
    parser.add_argument(
        '-t', choices=['win32', 'win64'],
        default='win64' if sys.maxsize > 2**32 else 'win32', dest='target',
        help='binaries to install, defaults to python\'s architecture'
    )
    parser.add_argument('-b', dest='binary_path', help='custom binary install path')
    parser.add_argument('-s', dest='script_path', help='custom script install path')
    parser.add_argument('--stub-output-file', default='', help='Don\'t update the typestubs generated by vsrepo.')
    parser.add_argument('--force-dist-info', action='store_true', default=False, help='')
    args = parser.parse_args(argv)

    if (args.operation in ['install', 'upgrade', 'uninstall']) and not args.package:
        e = 'Package argument required for install, upgrade and uninstall operations'
        if exit:
            print(e)
            sys.exit(1)
        raise ValueError(e)

    info = get_installation_info(args)

    package_list = VSPackages.from_file(Path(info.package_json_path))

    installed_packages = InstalledPackages(info, package_list)

    for name in args.package:
        try:
            assert isinstance(name, str)
            installed_packages.get_package_from_name(name)
        except Exception as e:
            if exit:
                print(e)
                sys.exit(1)
            raise e

    set_variables(args, info, package_list, installed_packages)

    if args.operation == 'update':
        return update_package_definition('http://www.vapoursynth.com/vsrepo/vspackages3.zip')
    elif args.operation == 'paths':
        return info.print_info()
    elif args.operation == 'genstubs':
        return update_genstubs()

    detect_installed_packages()

    if args.operation == 'installed':
        return list_installed_packages()
    elif args.operation == 'available':
        return list_available_packages()
    elif args.operation == 'gendistinfo':
        return rebuild_distinfo()

    if args.operation == 'uninstall':
        uninst = InstallPackageResult()
        for name in args.package:
            uninst += uninstall_package(name)

        if not uninst.success:
            print('No packages uninstalled')
        else:
            print(f"{uninst.success} package{uninst.success > 1 and 's' or 's'} uninstalled")

        return update_genstubs()

    rebuild_distinfo()

    inst = InstallPackageResult()
    if args.operation == 'install':
        action = 'installed'

        for name in args.package:
            inst += install_package(name)
    elif args.operation in {'upgrade', 'upgrade-all'}:
        action = 'upgraded'
        if args.operation == 'upgrade-all':
            for id in installed_packages:
                if installed_packages.is_package_upgradable(id, args.force):
                    pkg = installed_packages.get_package_from_id(id, True)
                    inst += upgrade_files(pkg)
        else:
            for name in args.package:
                inst += upgrade_package(name, args.force)

    update_genstubs()

    pack_str = f"package{inst.success > 1 and 's' or 's'}"
    deps_str = f"dependenc{inst.success > 1 and 'ies' or 'y'}"

    if not inst.success and not inst.success_dependecies:
        print('Nothing done')
    elif inst.success and not inst.success_dependecies:
        print(f'{inst.success} {pack_str} {action}')
    elif not inst.success and inst.success_dependecies:
        print(f'{inst.success_dependecies} missing {deps_str} {action}')
    else:
        print(f'{inst.success} {pack_str} {action} and {inst.success_dependecies} additional {deps_str} {action}')

    if inst.error:
        print(f'{inst.error} {pack_str} failed')


if __name__ == '__main__':
    main(exit_on_error=True)
